// This is the TodoMVC specification from 
// https://wickstrom.tech/programming/2020/07/02/the-todomvc-showdown-testing-with-webcheck.html
// ported to the new Specstrom-backed implementation of Quickstrom.
// 
// Would be nice to limit the imports as in the comments below.
// Also they're commented out until we have deduplication of
// imported definitions. 
// 
// import list;
// import string;
import quickstrom;
import todomvc/operators;
import todomvc/elements;

//-------------------------------------------------
// Actions
//-------------------------------------------------

action ~pageLoaded? = loaded? timeout 1000;

action ~ready? = changed?(`body`);

action ~selectOtherFilter! = click!(`.todoapp .filters a:not(.selected)`)
  // weighted 5.0
  when not isInEditMode
  ;

action ~selectSameFilter! = click!(`.todoapp .filters a.selected`) when not isInEditMode;

action ~toggleAllTodos! = click!(`.todoapp label[for=toggle-all]`) when not isInEditMode;

action ~editTodo! = doubleClick!(`.todo-list li label`) when not isInEditMode;

action ~deleteTodo! = click!(`.todoapp .destroy`) when not isInEditMode;

action ~focusInput! = focus!(`.todoapp .new-todo`) when not isInEditMode;

action ~typePendingText! = [keyPress!(" "), keyPress!("a"), keyPress!("b"), keyPress!(keys.backspace)] 
  when newTodoInput.active 
  // weighted 5.0
  ;

action ~typeEditText! = [
    keyPress!(" "),
    keyPress!("a"),
    keyPress!(keys.backspace),
  ] 
  when isInEditMode
  // weighted 5.0
  ;

action ~abortEdit! = [keyPress!(keys.escape)] when isInEditMode;

action ~createTodo! = [keyPress!(keys.return)] 
  when newTodoInput != null 
    && newTodoInput.pendingText != ""
    && newTodoInput.active
  // weighted 5.0
  ;

//-------------------------------------------------
// States & Transitions
//-------------------------------------------------

let ~notLoaded = newTodoInput == null;

let ~initial =
    selectedFilter == null
      && numItems == 0
      && newTodoInput != null
      && newTodoInput.pendingText == "";

let ~focusNewTodo =
  not newTodoInput.active
    && newTodoInput.active becomes true
    && unchanged([
      selectedFilter,
      newTodoInput.pendingText,
      availableFilters,
      items,
      todoCount
    ]);

let ~enterNewTodoText =
  changed(newTodoInput.pendingText)
    && unchanged(items)
    && unchanged(selectedFilter);

let ~changeFilter =
  changed(selectedFilter)
  // Going to a different filter should not change the pending todo item.
  && unchanged(newTodoInput.pendingText)
  && (match selectedFilter {
    // Can't change filter when the filters are hidden.
    | case null { false }
    // Going from "All" to another filter cannot increase number of items.
    | case "All" { numItems becomes <= numItems }
    | case "Active" { selectedFilter becomes "All" || selectedFilter becomes "Completed" }
    | case "Completed" { selectedFilter becomes "All" || selectedFilter becomes "Active" }
  });

let ~setSameFilter =
    unchanged([
      selectedFilter,
      newTodoInput.pendingText,
      availableFilters,
      for item in items { item.text },
      todoCount
    ]);

let ~addNew =
  let trimmed = trim(newTodoInput.pendingText);
  trimmed != ""
  && newTodoInput.pendingText becomes ""
  && selectedFilter does not become null
  && (match selectedFilter {
    // Adding the first item should enable the last used filter (which we don't know
    // what it was).
    | case null { 
      selectedFilter does not become "Completed" ==> lastItemText becomes trimmed 
    }
    // Both in the "All' and "Active" filters the item should be appended to the
    // list of items.
    | case "All" { lastItemText becomes trimmed && unchanged(selectedFilter) }
    | case "Active" { lastItemText becomes trimmed && unchanged(selectedFilter) }
    // In the "Completed" filter we can't see the new item.
    | case "Completed" { unchanged([items, selectedFilter]) }
  });

let ~checkOne =
  unchanged(newTodoInput.pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All" { unchanged(numItems) && (numChecked becomes < numChecked) }
      | case "Active" { (numItems becomes > numItems) && (todoCount becomes > todoCount) }
      | case other { false }
    });

let ~uncheckOne =
  unchanged(newTodoInput.pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All" { unchanged(numItems) && numChecked becomes > numChecked }
      | case "Completed" { numItems becomes > numItems && todoCount becomes < todoCount }
      | case other { false }
    });

let ~delete =
  unchanged(newTodoInput.pendingText)
    && (selectedFilter != null)
    && (match numItems {
      | case 0 { false }
      | case 1 {
        numItems becomes 0 && selectedFilter becomes null
      }
      | case other {
          unchanged(selectedFilter)
          && (numItems -= 1)
          && match selectedFilter {
            | case "Active" { todoCount -= 1 }
            | case "Completed" { unchanged(todoCount) }
            | case "All" { true }
          }
      }
    })
  ;


let ~toggleAll =
  unchanged(newTodoInput.pendingText)
    && unchanged(selectedFilter)
    && nextT (if toggleAllChecked { numItems == numChecked } else { numItems == numUnchecked })
    && (match selectedFilter {
      | case null { false }
      | case "All" { 
        unchanged(numItems) 
        && match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items 
          // are unchecked.
          | case 0 { numUnchecked becomes numChecked }
          // If there are unchecked (active) items, they're checked.
          | case n { numItems becomes numChecked } 
        }
      }
      | case "Active" {
        match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items
          // are unchecked (but we can't see how many there are, just more than 0).
          | case 0 { numItems becomes > 0 }
          // If there are unchecked (active) items, they're checked.
          | case n { numItems becomes 0 }
        }
      }
      | case "Completed" { 
        match todoCount {
          | case 0 { numItems becomes 0 }
          | case n { numItems += todoCount }
        }
        
      }
    });

let ~startEditing =
  (numInEditMode == 0) ~> (numInEditMode == 1 && itemInEditMode.editInput.active)
    && unchanged([
      selectedFilter,
      availableFilters,
      for item in items { item.text },
      todoCount
    ])
    && (newTodoInput != null ==> unchanged(newTodoInput.pendingText));

let ~enterEditText =
  numInEditMode == 1
    && unchanged(numInEditMode)
    && nextT (not contains(keyPress!(keys.escape), happened))
    && changed(itemInEditMode.editInput.pendingText when itemInEditMode != null)
    && unchanged(for item in items { item.text })
    && unchanged(selectedFilter);

let ~abortEdit =
  (numInEditMode == 1 ~> numInEditMode == 0)
    && nextT (contains(keyPress!(keys.escape), happened))
    && unchanged(for item in items { item.text });

let ~commitEdit =
  (numInEditMode == 1 ~> numInEditMode == 0)
    && nextT (not contains(keyPress!(keys.escape), happened))
    && (match itemInEditMode.editInput.pendingText {
      | case "" { numItems -= 1 }
      | case newText { 
          let oldItem = itemInEditMode;
          nextT (exists item in items { item.index == oldItem.index && item.text == newText})
      }
    })
    && unchanged([
      selectedFilter,
      newTodoInput.pendingText,
      availableFilters
    ]);

let ~hasFilters = numItems == 0 || availableFilters == ["All", "Active", "Completed"];

let ~correctFilterStates =
  match selectedFilter {
    | case null { true }
    | case "All"  { todoCount == numUnchecked && todoCount <= numItems }
    | case "Active"  { numItems == todoCount }
    | case "Completed" { true }
  };

let ~prop_safety =
  notLoaded until {100}
  (
  initial
    && always
       ( focusNewTodo
           || enterNewTodoText
           || addNew
           || changeFilter
           || setSameFilter
           || checkOne
           || uncheckOne
           || delete
           || toggleAll
           || startEditing
           || enterEditText
           || abortEdit
           || commitEdit
       )
    && always (hasFilters && correctFilterStates)
  );

check prop_safety with * when [pageLoaded?, ready?];
