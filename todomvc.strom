// Would be nice to limit the imports as in the comments below.
// Also they're commented out until we have deduplication of
// imported definitions.

// import list; // (zip, mapNotNull, length, first, last);
// import string; //  (trim, split, parseInt);
import quickstrom;

//-------------------------------------------------
// Operators
//-------------------------------------------------

syntax _>'_ 8;
let ~x >' n = freeze x' = x. next (x' > n);

syntax _>='_ 8;
let ~x >=' n = freeze x' = x. next (x' >= n);

syntax _<'_ 8;
let ~x <' n = freeze x' = x. next (x' > n);

syntax _<='_ 8;
let ~x >=' n = freeze x' = x. next (x' >= n);

syntax _+='_ 8;
let ~x +=' n = freeze x' = x. next (x' == x + n);

syntax _-='_ 8;
let ~x -=' n = freeze x' = x. next (x' == x - n);

syntax _=='_ 8;
let ~a ==' b = next (a == b);

//-------------------------------------------------
// Actions
//-------------------------------------------------

action ~selectOtherFilter! = click!(`.todoapp .filters a:not(.selected)`)
  // weighted 5.0
  ;

action ~selectSameFilter! = click!(`.todoapp .filters a.selected`);

action ~toggleAllTodos! = click!(`.todoapp label[for=toggle-all]`);

action ~deleteTodo! = click!(`.todoapp .destroy`);

action ~focusInput! = focus!(`.todoapp .new-todo`) when not `.todoapp .new-todo`.active
  // weighted 5.0
  ;

action ~clickAnyLink! = click!(`.todoapp a`)
  // weighted 5.0
  ;

action ~createTodo! = [keyPress!(keys.return), keyPress!("a")] when first(`.todoapp .new-todo`).active
  // weighted 5.0
  ;

let ~selectedFilter = 
  let element = first(`.todoapp .filters a.selected`);
  if element != null { element.textContent };

let ~items =
  for [li, label] in zip(`.todo-list li`, `.todo-list li label`) {
    if li.css.display != "none" { label }
  };

let ~lastItem = last(items);

let ~numItems = length(items);

let ~checkboxes = `.todo-list li input[type=checkbox]`;

let ~numUnchecked = length(filter(fun c. not c.checked, checkboxes));

let ~numChecked = length(filter(fun c. c.checked, checkboxes));

let ~pendingText = 
  let element = first(`.todoapp .new-todo`);
  if element != null { element.value } else { "" };

let ~numItemsLeft =
    let strong = first(`.todoapp .todo-count strong`).textContent;
    if strong != null {
      parseInt(first(split(" ", trim(strong))))
    } else { 0 };

let ~availableFilters = map(fun f. f.textContent, `.todoapp .filters a`);

//-------------------------------------------------
// States & Transitions
//-------------------------------------------------

let ~initial =
    (selectedFilter == null || selectedFilter == "All")
      && numItems == 0
      && pendingText == "";

let ~enterText =
    not unchanged(pendingText)
      && unchanged(items)
      && unchanged(selectedFilter);

let ~changeFilter =
  // adding the first todo item switches to the All filter
  selectedFilter == null && next selectedFilter == "All"
  // going from "All" to some filter (including "All") cannot increase number of items
  || selectedFilter == "All" && numItems >=' numItems
  // going to "Active" should only show as many items as are considered left to do
  || next (selectedFilter == "Active" && numItemsLeft == numUnchecked && numItems == numUnchecked)
  // going to a different filter should not change the pending todo item
  || not unchanged(selectedFilter) && unchanged(pendingText)
  ;

let ~addNew =
  next (pendingText == "")
    && not (next (selectedFilter == null))

    // && (match selectedFilter {
    //   | case "All". pendingText ==' lastItem
    //   | case "Active". pendingText ==' lastItem
    //   | case "Completed". unchanged(items)
    // })

    && selectedFilter == "All" ==> pendingText ==' lastItem
    && selectedFilter == "Active" ==> pendingText ==' lastItem
    && selectedFilter == "Completed" ==> unchanged(items)
    ;

let ~checkOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (selectedFilter != "Completed")

    // && (match selectedFilter {
    //   | case "All". unchanged(numItems) && (numChecked <' numChecked)
    //   | case "Active". (numItems >' numItems) && (numItemsLeft >' numItemsLeft)
    // })

    && selectedFilter == "All" ==> unchanged(numItems) && (numChecked <' numChecked)
    && selectedFilter == "Active" ==> (numItems >' numItems) && (numItemsLeft >' numItemsLeft)
    ;

let ~uncheckOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && selectedFilter != "Active"
    && selectedFilter == "All" ==> unchanged(numItems) && numChecked >' numChecked
    && selectedFilter == "Completed" ==> numItems >' numItems && numItemsLeft <' numItemsLeft;

let ~delete =
  unchanged(pendingText)
    && (selectedFilter != null)
    && (numItems == 1) ==>
      (if selectedFilter == "All" { 
        // removing the last todo item causes the filters to be hidden
        next (numItems == 0 && selectedFilter == null) 
      } else {
        // in other filters, there *might* be other todo items that are just not visible
        next (numItems == 0)
      })
    && ((numItems > 1) ==> (
      (unchanged(selectedFilter)
        && (numItems -=' 1)
        && ((selectedFilter == "Active") ==> (numItemsLeft -=' 1))
        && (selectedFilter == "Completed" ==> unchanged(numItemsLeft))
        )))
  ;

let ~toggleAll =
    unchanged(pendingText)
      && unchanged(selectedFilter)
      && selectedFilter != null
      && selectedFilter == "All" ==> unchanged(numItems) && next (numItems == numChecked)
      && (selectedFilter == "Active" ==>
           // If there are active items, they're checked
           (numItems > 0 && next (numItems == 0))
           // If there are none, all checked items are unchecked (but we can't see how many
           // there are, just more than 0)
           || (numItems == 0 && next (numItems > 0))
         )
      && selectedFilter == "Completed" ==> numItems +=' numItemsLeft
  ;


let ~hasFilters = numItems == 0 || availableFilters == ["All", "Active", "Completed"];

let ~prop_safety =
  initial
    && always
        ( enterText
            || addNew
            // || changeFilter
            // || checkOne
            // || uncheckOne
            // || delete
            // || toggleAll
        )
    // && always hasFilters
    ;

// let ~ready? = changed?(`.todoapp .new-todo`) when length(`.todoapp .new-todo`) == 1; // is the query result a list?

check prop_safety with * when loaded?;
