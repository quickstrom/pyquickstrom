// Would be nice to limit the imports as in the comments below.
// Also they're commented out until we have deduplication of
// imported definitions. 
// import list; // (zip, mapNotNull, length, first, last);
// import string; //  (trim, split, parseInt);
import quickstrom;

//-------------------------------------------------
// Operators
//-------------------------------------------------

syntax _>'_ 8;
let ~x >' n = nextT (x > n);

syntax _>='_ 8;
let ~x >=' n = nextT (x >= n);

syntax _<'_ 8;
let ~x <' n = nextT (x > n);

syntax _<='_ 8;
let ~x <=' n = nextT (x <= n);

syntax _+='_ 8;
let ~x +=' n = freeze x' = x { nextT (x == x' + n) };

syntax _-='_ 8;
let ~x -=' n = freeze x' = x { nextT (x == x' - n) };

syntax _=='_ 8;
let ~a ==' b = nextT (a == b);

syntax _!='_ 8;
let ~a !=' b = nextT (a != b);

//-------------------------------------------------
// DOM state
//-------------------------------------------------

let ~selectedFilter = 
  let element = first(`.todoapp .filters a.selected`);
  if element != null && element.visible { element.textContent };

let ~items =
  for [li, label] in zip(`.todo-list li`, (for label in `.todo-list li label` { label.textContent })) {
    if li.css.display != "none" { trim(label) }
  };

let ~lastItem = last(items);

let ~numItems = length(items);

let ~checkboxes = `.todo-list li input[type=checkbox]`;

let ~numUnchecked = length(for c in checkboxes { c when not c.checked });

let ~numChecked = length(for c in checkboxes { c when c.checked });

let ~pendingText = first(for e in `.todoapp .new-todo` { e.value });

let ~todoCount =
    let strong = first(for e in `.todoapp .todo-count strong` { e.textContent });
    if strong != null {
      parseInt(first(split(" ", trim(strong))))
    } else { 0 };

let ~availableFilters = for f in `.todoapp .filters a` { f.textContent };

//-------------------------------------------------
// Actions
//-------------------------------------------------

action ~selectOtherFilter! = click!(`.todoapp .filters a:not(.selected)`)
  // weighted 5.0
  ;

action ~selectSameFilter! = click!(`.todoapp .filters a.selected`);

action ~toggleAllTodos! = click!(`.todoapp label[for=toggle-all]`);

action ~deleteTodo! = click!(`.todoapp .destroy`);

// action ~clickAnyLink! = click!(`.todoapp a`)
  // weighted 5.0
// ;

action ~focusInput! = focus!(`.todoapp .new-todo`)
  // weighted 5.0
  ;

action ~enterPendingText! = [keyPress!(" "), keyPress!("a"), keyPress!("b")] when `.todoapp .new-todo`.active
  // weighted 5.0
  ;

action ~createTodo! = [keyPress!(keys.return)] when pendingText != ""
  // weighted 5.0
  ;

//-------------------------------------------------
// States & Transitions
//-------------------------------------------------

let ~initial =
    selectedFilter == null
      && numItems == 0
      && pendingText == "";

let ~enterText =
  (not unchanged(pendingText))
    && unchanged(items)
    && unchanged(selectedFilter);

let ~changeFilter =
  (not unchanged(selectedFilter))
  // Going to a different filter should not change the pending todo item.
  && unchanged(pendingText)
  && (match selectedFilter {
    // Can't change filter when the filters are hidden.
    | case null { false }
    // Going from "All" to another filter cannot increase number of items.
    | case "All" { numItems <=' numItems }
    | case "Active" { selectedFilter ==' "All" || selectedFilter ==' "Completed" }
    | case "Completed" { selectedFilter ==' "All" || selectedFilter ==' "Active" }
  });

let ~addNew =
  let trimmed = trim(pendingText);
  trimmed != ""
  && pendingText ==' ""
  && selectedFilter !=' null
  && (match selectedFilter {
    // Adding the first item should enable the last used filter (which we don't know
    // what it was).
    | case null { 
      selectedFilter !=' "Completed" ==> lastItem ==' trimmed 
    }
    // Both in the "All' and "Active" filters the item should be appended to the
    // list of items.
    | case "All" { lastItem ==' trimmed && unchanged(selectedFilter) }
    | case "Active" { lastItem ==' trimmed && unchanged(selectedFilter) }
    // In the "Completed" filter we can't see the new item.
    | case "Completed" { unchanged([items, selectedFilter]) }
  });

let ~checkOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All" { unchanged(numItems) && (numChecked <' numChecked) }
      | case "Active" { (numItems >' numItems) && (todoCount >' todoCount) }
      | case other { false }
    });

let ~uncheckOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All" { unchanged(numItems) && numChecked >' numChecked }
      | case "Completed" { numItems >' numItems && todoCount <' todoCount }
      | case other { false }
    });

let ~delete =
  unchanged(pendingText)
    && (selectedFilter != null)
    && (match numItems {
      | case 0 { false }
      | case 1 {
        numItems ==' 0 && selectedFilter ==' null
      }
      | case other {
        unchanged(selectedFilter)
          && (numItems -=' 1)
          && ((selectedFilter == "Active" && todoCount -=' 1)
          || (selectedFilter == "Completed" ==> unchanged(todoCount))
            )
      }
    })
  ;

let ~doNothing =
  unchanged([
    selectedFilter,
    pendingText,
    availableFilters,
    items,
    numUnchecked,
    numChecked,
    todoCount
  ]);

let ~toggleAll =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case null { false }
      | case "All" { 
        unchanged(numItems) 
        && match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items 
          // are unchecked.
          | case 0 { 
            numUnchecked ==' numChecked 
            // true
            }
          // If there are unchecked (active) items, they're checked.
          | case n { 
            nextT (numItems == numChecked) 
            // true
            }
        }
      }
      | case "Active" {
        match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items
          // are unchecked (but we can't see how many there are, just more than 0).
          | case 0 { nextT (numItems > 0) }
          // If there are unchecked (active) items, they're checked.
          | case n { nextT (numItems == 0) }
        }
      }
      | case "Completed" { 
        match todoCount {
          | case 0 { numItems ==' 0 }
          | case n { numItems +=' todoCount }
        }
        
      }
    });


let ~hasFilters = numItems == 0 || availableFilters == ["All", "Active", "Completed"];

let ~correctFilterStates =
  match selectedFilter {
    | case null { true }
    | case "All"  { todoCount == numUnchecked && todoCount <= numItems }
    | case "Active"  { numItems == todoCount }
    | case "Completed" { true }
  };

let ~prop_safety =
  initial
    && always
       ( enterText
           || addNew
           || changeFilter
           || checkOne
           || uncheckOne
           || delete
           || toggleAll
           || doNothing
       )
    && always (hasFilters && correctFilterStates);

check prop_safety with * when loaded?;
