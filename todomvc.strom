// Would be nice to limit the imports as in the comments below.
// Also they're commented out until we have deduplication of
// imported definitions. 
// import list; // (zip, mapNotNull, length, first, last);
// import string; //  (trim, split, parseInt);
import quickstrom;

//-------------------------------------------------
// Operators
//-------------------------------------------------

syntax _>'_ 8;
let ~x >' n = nextT (x > n);

syntax _>='_ 8;
let ~x >=' n = nextT (x >= n);

syntax _<'_ 8;
let ~x <' n = nextT (x > n);

syntax _<='_ 8;
let ~x <=' n = nextT (x <= n);

syntax _+='_ 8;
let ~x +=' n = freeze x' = x. nextT (x == x' + n);

syntax _-='_ 8;
let ~x -=' n = freeze x' = x. nextT (x == x' - n);

syntax _=='_ 8;
let ~a ==' b = nextT (a == b);

//-------------------------------------------------
// Actions
//-------------------------------------------------

action ~selectOtherFilter! = click!(`.todoapp .filters a:not(.selected)`)
  // weighted 5.0
  ;

action ~selectSameFilter! = click!(`.todoapp .filters a.selected`);

action ~toggleAllTodos! = click!(`.todoapp label[for=toggle-all]`);

action ~deleteTodo! = click!(`.todoapp .destroy`);

action ~focusInput! = focus!(`.todoapp .new-todo`)
  // weighted 5.0
  ;

// action ~clickAnyLink! = click!(`.todoapp a`)
  // weighted 5.0
// ;

action ~createTodo! = [keyPress!(keys.return), keyPress!("a")] when first(for e in `.todoapp .new-todo`. e.active) ?? false
  // weighted 5.0
  ;

//-------------------------------------------------
// DOM state
//-------------------------------------------------

let ~selectedFilter = 
  let element = first(`.todoapp .filters a.selected`);
  if element != null { element.textContent };

let ~items =
  for [li, label] in zip(`.todo-list li`, (for label in `.todo-list li label`. label.textContent)) {
    if li.css.display != "none" { trim(label) }
  };

let ~lastItem = last(items);

let ~numItems = length(items);

let ~checkboxes = `.todo-list li input[type=checkbox]`;

let ~numUnchecked = length(for c in checkboxes. c when not c.checked);

let ~numChecked = length(for c in checkboxes. c when c.checked);

let ~pendingText = first(for e in `.todoapp .new-todo` { e.value }) ?? "";

let ~todoCount =
    let strong = first(for e in `.todoapp .todo-count strong`. e.textContent);
    if strong != null {
      parseInt(first(split(" ", trim(strong))))
    } else { 0 };

let ~availableFilters = for f in `.todoapp .filters a`. f.textContent;

//-------------------------------------------------
// States & Transitions
//-------------------------------------------------

let ~initial =
    (selectedFilter == null || selectedFilter == "All")
      && numItems == 0
      && pendingText == "";

let ~enterText =
    (not unchanged(pendingText))
      && unchanged(items)
      && unchanged(selectedFilter)
      ;

let ~changeFilter =
  (not unchanged(selectedFilter))
  // going to a different filter should not change the pending todo item
  && unchanged(pendingText)
  && match selectedFilter {
    // adding the first todo item switches to the All filter
    | case null { selectedFilter ==' "All" }
    // going from "All" to some filter (including "All") cannot increase number of items
    | case "All" { numItems <=' numItems }
    // going to "Active" should only show as many items as are considered left to do
    | case other { true }
  }
  ;

let ~addNew =
  nextT (pendingText == "")
  && nextT (selectedFilter != null)
  && (match selectedFilter {
    | case "All". lastItem ==' pendingText
    | case "Active". lastItem ==' pendingText
    | case "Completed". unchanged(items)
    | case other. false
  });

let ~checkOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All". unchanged(numItems) && (numChecked <' numChecked)
      | case "Active". (numItems >' numItems) && (todoCount >' todoCount)
      | case other. false
    });

let ~uncheckOne =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case "All". unchanged(numItems) && numChecked >' numChecked
      | case "Completed". numItems >' numItems && todoCount <' todoCount
      | case other. false
    });

let ~delete =
  unchanged(pendingText)
    && (selectedFilter != null)
    && (match numItems {
      | case 0 { false }
      | case 1 {
        match selectedFilter {
          | case "All" { 
            // removing the last todo item causes the filters to be hidden
            nextT (numItems == 0 && selectedFilter == null) 
          }
          | case other {
            // in other filters, there *might* be other todo items that are just not visible
            nextT (numItems == 0) && unchanged(selectedFilter)
          }
        }
      }
      | case other {
        unchanged(selectedFilter)
          && (numItems -=' 1)
          && ((selectedFilter == "Active" && todoCount -=' 1)
          || (selectedFilter == "Completed" ==> unchanged(todoCount))
            )
      }
    })
  ;

let ~doNothing =
  unchanged([
    pendingText,
    availableFilters 
  ])
  && (selectedFilter != null) ==> unchanged([
    selectedFilter,
    items,
    numUnchecked,
    numChecked,
    todoCount
  ]);

let ~toggleAll =
  unchanged(pendingText)
    && unchanged(selectedFilter)
    && (match selectedFilter {
      | case null { false }
      | case "All" { 
        unchanged(numItems) 
        && match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items 
          // are unchecked.
          | case 0 { 
            numUnchecked ==' numChecked 
            // true
            }
          // If there are unchecked (active) items, they're checked.
          | case n { 
            nextT (numItems == numChecked) 
            // true
            }
        }
      }
      | case "Active" {
        match numUnchecked {
          // If there are no unchecked (active) items, all checked (completed) items
          // are unchecked (but we can't see how many there are, just more than 0).
          | case 0 { nextT (numItems > 0) }
          // If there are unchecked (active) items, they're checked.
          | case n { nextT (numItems == 0) }
        }
      }
      | case "Completed" { 
        match todoCount {
          | case 0 { numItems ==' 0 }
          | case n { numItems +=' todoCount }
        }
        
      }
    });


let ~hasFilters = numItems == 0 || availableFilters == ["All", "Active", "Completed"];

let ~correctFilterStates =
  match selectedFilter {
    | case null { true }
    | case "All"  { todoCount == numUnchecked && todoCount <= numItems }
    | case "Active"  { numItems == todoCount }
    | case "Completed" { true }
  };

let ~prop_safety =
  initial
    && always
       ( enterText
           || addNew
           || changeFilter
           || checkOne
           || uncheckOne
           || delete
           || toggleAll
           || doNothing
       )
    && always (hasFilters && correctFilterStates);

check prop_safety with * when loaded?;
